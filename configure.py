#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
from pathlib import Path

# Project paths
ROOT = Path(__file__).parent
CONFIG_DIR = ROOT / "config"
SPLAT_YAML = CONFIG_DIR / "SLUS_204.69.yaml"
ISO_DIR = ROOT / "iso"
BUILD_DIR = ROOT / "build"
ELF_PATH = BUILD_DIR / "SLUS_204.69.elf"

# Original ELF
ORIGINAL_ELF = ISO_DIR / "SLUS_204.69"
ORIGINAL_SHA1 = "fd206d5715a322830f7fa9285fb4a09276ac2a63"

# Tools
CROSS = "/usr/local/ps2dev/ee/bin/mips64r5900el-ps2-elf-"
AS = f"{CROSS}as"
LD = "/usr/local/ps2dev/ee/bin/mips64r5900el-ps2-elf-ld"
OBJCOPY = f"mips-linux-gnu-objcopy"
CC = f"{CROSS}gcc"

# Assembler flags for the PS2 Emotion Engine (MIPS III + EE extensions)
ASFLAGS = "-march=r5900 -mabi=32 -Iinclude"

# Linker flags
LDFLAGS = "--allow-multiple-definition -m elf32lr5900 --noinhibit-exec -m elf32lr5900"


def clean():
    """Remove build artifacts."""
    import shutil
    dirs_to_clean = [BUILD_DIR]
    for d in dirs_to_clean:
        if d.exists():
            shutil.rmtree(d)
            print(f"Cleaned {d}")


def split():
    """Run Splat to split the ROM."""
    # Generate the ROM from the ELF if it doesn't exist
    rom_path = CONFIG_DIR / "SLUS_204.69.rom"
    if not rom_path.exists():
        print("Generating ROM from ELF...")
        subprocess.run(
            [OBJCOPY, "-O", "binary", "--gap-fill=0x00",
             str(ORIGINAL_ELF), str(rom_path)],
            check=True,
        )

    print("Running Splat...")
    subprocess.run(
        [sys.executable, "-m", "splat", "split", str(SPLAT_YAML)],
        check=True,
    )


def find_asm_files():
    """Find all assembly files produced by Splat."""
    asm_files = []
    for path in sorted(ROOT.rglob("asm/**/*.s")):
        asm_files.append(path.relative_to(ROOT))
    return asm_files


def find_src_files():
    """Find all C source files (decompiled functions)."""
    src_files = []
    src_dir = ROOT / "src"
    if src_dir.exists():
        for path in sorted(src_dir.rglob("*.c")):
            src_files.append(path.relative_to(ROOT))
    return src_files


def find_asset_files():
    """Find all binary asset files."""
    asset_files = []
    assets_dir = ROOT / "assets"
    if assets_dir.exists():
        for path in sorted(assets_dir.rglob("*.bin")):
            asset_files.append(path.relative_to(ROOT))
    return asset_files


def generate_ninja(asm_files, src_files, asset_files):
    """Generate build.ninja file."""
    BUILD_DIR.mkdir(parents=True, exist_ok=True)

    ninja_path = ROOT / "build.ninja"
    ld_script = CONFIG_DIR / "SLUS_204.69.ld"

    with open(ninja_path, "w") as f:
        # Header
        f.write("# Generated by configure.py - do not edit manually\n")
        f.write(f"builddir = {BUILD_DIR}\n\n")

        # Rules
        f.write(f"rule as\n")
        f.write(f"  command = {AS} {ASFLAGS} -o $out $in\n")
        f.write(f"  description = AS $in\n\n")

        f.write(f"rule cc\n")
        f.write(f"  command = {CC} -c -o $out $in\n")
        f.write(f"  description = CC $in\n\n")

        f.write(f"rule ld\n")
        f.write(f"  command = {LD} {LDFLAGS} -o $out -T $ldscript $in\n")
        f.write(f"  description = LD $out\n\n")

        f.write(f"rule objcopy_bin\n")
        f.write(f"  command = {CROSS}objcopy -I binary -O elf32-littlemips -B mips $in $out\n")
        f.write(f"  description = OBJCOPY $in\n\n")

        f.write(f"rule sha1check\n")
        f.write(f"  command = echo \"{ORIGINAL_SHA1}  {ORIGINAL_ELF}\" | sha1sum -c -\n")
        f.write(f"  description = Verifying original ELF checksum\n\n")

        # Build assembly files
        obj_files = []
        for asm in asm_files:
            obj = BUILD_DIR / asm.with_suffix(".o")
            obj_files.append(str(obj))
            f.write(f"build {obj}: as {asm}\n")

        # Build C source files
        for src in src_files:
            obj = BUILD_DIR / src.with_suffix(".o")
            obj_files.append(str(obj))
            f.write(f"build {obj}: cc {src}\n")

        # Build binary assets
        for asset in asset_files:
            obj = BUILD_DIR / asset.with_suffix(".o")
            obj_files.append(str(obj))
            f.write(f"build {obj}: objcopy_bin {asset}\n")

        f.write("\n")

        # Link
        all_objs = " ".join(obj_files)
        f.write(f"build {ELF_PATH}: ld {all_objs}\n")
        f.write(f"  ldscript = {ld_script}\n\n")

        # Default target
        f.write(f"default {ELF_PATH}\n")

    print(f"Generated {ninja_path}")
    print(f"  Assembly files: {len(asm_files)}")
    print(f"  Source files:   {len(src_files)}")
    print(f"  Asset files:    {len(asset_files)}")


def generate_objdiff():
    """Generate objdiff.json for function diffing."""
    import json

    objdiff_config = {
        "min_version": "2.0.0",
        "custom_make": "ninja",
        "build_target": str(ELF_PATH),
        "target_dir": "expected",
        "base_dir": "build",
    }

    objdiff_path = ROOT / "objdiff.json"
    with open(objdiff_path, "w") as f:
        json.dump(objdiff_config, f, indent=2)
    print(f"Generated {objdiff_path}")


def main():
    parser = argparse.ArgumentParser(description="Configure the Xenosaga Episode I decomp build")
    parser.add_argument("--clean", action="store_true", help="Clean build artifacts before configuring")
    parser.add_argument("--split", action="store_true", help="Run Splat to split the ROM")
    parser.add_argument("--no-split", action="store_true", help="Skip splitting even if asm/ doesn't exist")
    args = parser.parse_args()

    # Verify original ELF exists
    if not ORIGINAL_ELF.exists():
        print(f"Error: {ORIGINAL_ELF} not found.")
        print(f"Place the original SLUS_204.69 in the iso/ folder.")
        sys.exit(1)

    # Clean if requested
    if args.clean:
        clean()

    # Split if requested or if asm/ doesn't exist
    if args.split or (not args.no_split and not (ROOT / "asm").exists()):
        split()

    # Find all source files
    asm_files = find_asm_files()
    src_files = find_src_files()
    asset_files = find_asset_files()

    if not asm_files:
        print("Error: No assembly files found. Run with --split to split the ROM.")
        sys.exit(1)

    # Generate build files
    generate_ninja(asm_files, src_files, asset_files)
    generate_objdiff()

    print("\nBuild configured! Run 'ninja' to build.")


if __name__ == "__main__":
    main()
